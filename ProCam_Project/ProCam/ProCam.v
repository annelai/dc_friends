//=======================================================
// Copyright (c) 2015 by NTUEE DC_Friends
//
// [Projrctor Painted Face Removal Project]
//=======================================================
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
//to set the VGA solution
`include "VGA_Param.h" 
module ProCam(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,

	//////////// VGA //////////
	VGA_B,
	VGA_BLANK_N,
	VGA_CLK,
	VGA_G,
	VGA_HS,
	VGA_R,
	VGA_SYNC_N,
	VGA_VS,

	//////////// I2C for HSMC  //////////
	//I2C_SCLK,
	//I2C_SDAT,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// SRAM //////////
	SRAM_ADDR,
	SRAM_CE_N,
	SRAM_DQ,
	SRAM_LB_N,
	SRAM_OE_N,
	SRAM_UB_N,
	SRAM_WE_N,

	//////////// GPIO, GPIO connect to D5M - 5M Pixel Camera //////////
	D5M_D,
	D5M_FVAL,
	D5M_LVAL,
	D5M_PIXLCLK,
	D5M_RESET_N,
	D5M_SCLK,
	D5M_SDATA,
	D5M_STROBE,
	D5M_TRIGGER,
	D5M_XCLKIN,

	//////////// HSMC, HSMC connect to DVI - FullHD TX/RX //////////
	//DVI_EDID_WP,
	//DVI_RX_CLK,
	//DVI_RX_CTL,
	//DVI_RX_D,
	//DVI_RX_DDCSCL,
	//DVI_RX_DDCSDA,
	//DVI_RX_DE,
	//DVI_RX_HS,
	//DVI_RX_SCDT,
	//DVI_RX_VS,
	//DVI_TX_CLK,
	//DVI_TX_CTL,
	//DVI_TX_D,
	//DVI_TX_DDCSCL,
	//DVI_TX_DDCSDA,
	//DVI_TX_DE,
	//DVI_TX_DKEN,
	//DVI_TX_HS,
	//DVI_TX_HTPLG,
	//DVI_TX_ISEL,
	//DVI_TX_MSEN,
	//DVI_TX_PD_N,
	//DVI_TX_SCL,
	//DVI_TX_SDA,
	//DVI_TX_VS,

	LA_PIN
	//GPIO_LA
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout 		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// VGA //////////
output		     [7:0]		VGA_B;
output		          		VGA_BLANK_N;
output		          		VGA_CLK;
output		     [7:0]		VGA_G;
output		          		VGA_HS;
output		     [7:0]		VGA_R;
output		          		VGA_SYNC_N;
output		          		VGA_VS;

//////////// I2C for HSMC  //////////
//output		          		I2C_SCLK;
//inout 		          		I2C_SDAT;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [31:0]		DRAM_DQ;
output		     [3:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// SRAM //////////
output		    [19:0]		SRAM_ADDR;
output		          		SRAM_CE_N;
inout 		    [15:0]		SRAM_DQ;
output		          		SRAM_LB_N;
output		          		SRAM_OE_N;
output		          		SRAM_UB_N;
output		          		SRAM_WE_N;


//////////// GPIO, GPIO connect to D5M - 5M Pixel Camera //////////
input 		    [11:0]		D5M_D;
input 		          		D5M_FVAL;
input 		          		D5M_LVAL;
input 		          		D5M_PIXLCLK;
output		          		D5M_RESET_N;
output		          		D5M_SCLK;
inout 		          		D5M_SDATA;
input 		          		D5M_STROBE;
output		          		D5M_TRIGGER;
output		          		D5M_XCLKIN;


//////////// HSMC, HSMC connect to DVI - FullHD TX/RX //////////
//output		          		DVI_EDID_WP;
//input 		          		DVI_RX_CLK;
//input 		     [3:1]		DVI_RX_CTL;
//input 		    [23:0]		DVI_RX_D;
//inout 		          		DVI_RX_DDCSCL;
//inout 		          		DVI_RX_DDCSDA;
//input 		          		DVI_RX_DE;
//input 		          		DVI_RX_HS;
//input 		          		DVI_RX_SCDT;
//input 		          		DVI_RX_VS;
//output		          		DVI_TX_CLK;
//output		     [3:1]		DVI_TX_CTL;
//output		    [23:0]		DVI_TX_D;
//inout 		          		DVI_TX_DDCSCL;
//inout 		          		DVI_TX_DDCSDA;
//output		          		DVI_TX_DE;
//output		          		DVI_TX_DKEN;
//output		          		DVI_TX_HS;
//output		          		DVI_TX_HTPLG;
//output		          		DVI_TX_ISEL;
//output		          		DVI_TX_MSEN;
//output		          		DVI_TX_PD_N;
//output		          		DVI_TX_SCL;
//inout 		          		DVI_TX_SDA;
//output		          		DVI_TX_VS;

////////////// LA_PIN //////////////////
output			[35:0]		LA_PIN;
//output 			[35:0]		GPIO_LA;

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire	[15:0]	Read_DATA1;
wire	[15:0]	Read_DATA2;

wire	[11:0]	mCCD_DATA;
wire			mCCD_DVAL;
wire			mCCD_DVAL_d;
wire	[15:0]	X_Cont;
wire	[15:0]	Y_Cont;
wire	[9:0]	X_ADDR;
wire	[31:0]	Frame_Cont;
wire			DLY_RST_0;
wire			DLY_RST_1;
wire			DLY_RST_2;
wire			DLY_RST_3;
wire			DLY_RST_4;
wire			Read;
reg		[11:0]	rCCD_DATA;
reg				rCCD_LVAL;
reg				rCCD_FVAL;
wire	[11:0]	sCCD_R;
wire	[11:0]	sCCD_G;
wire	[11:0]	sCCD_B;
wire			sCCD_DVAL;

wire			sdram_ctrl_clk;
wire	[9:0]	oVGA_R;   				//	VGA Red[9:0]
wire	[9:0]	oVGA_G;	 				//	VGA Green[9:0]
wire	[9:0]	oVGA_B;   				//	VGA Blue[9:0]

//power on start
wire             auto_start;

//=======================================================
//  Structural coding
//=======================================================
// D5M
assign	D5M_TRIGGER	=	1'b1;  // tRIGGER
assign	D5M_RESET_N	=	DLY_RST_1;
assign  VGA_CTRL_CLK = ~VGA_CLK;




//assign	LEDR		=	SW;
assign	LEDG		=	Y_Cont;
//assign	UART_TXD = UART_RXD;

//fetch the high 8 bits
assign  VGA_R = oVGA_R[9:2];
assign  VGA_G = oVGA_G[9:2];
assign  VGA_B = oVGA_B[9:2];

//D5M read 

always@(posedge D5M_PIXLCLK)
begin
	rCCD_DATA	<=	D5M_D;
	rCCD_LVAL	<=	D5M_LVAL;
	rCCD_FVAL	<=	D5M_FVAL;
end


//auto start when power on
assign auto_start = ((KEY[0])&&(DLY_RST_3)&&(!DLY_RST_4))? 1'b1:1'b0;
//Reset module
Reset_Delay			u2	(	.iCLK(CLOCK2_50),
							.iRST(KEY[0]),
							.oRST_0(DLY_RST_0),
							.oRST_1(DLY_RST_1),
							.oRST_2(DLY_RST_2),
							.oRST_3(DLY_RST_3),
							.oRST_4(DLY_RST_4)
						);
//D5M image capture
CCD_Capture			u3	(	.oDATA(mCCD_DATA),
							.oDVAL(mCCD_DVAL),
							.oX_Cont(X_Cont),
							.oY_Cont(Y_Cont),
							.oFrame_Cont(Frame_Cont),
							.iDATA(rCCD_DATA),
							.iFVAL(rCCD_FVAL),
							.iLVAL(rCCD_LVAL),
							.iSTART(!KEY[3]|auto_start),
							.iEND(!KEY[2]),
							.iCLK(~D5M_PIXLCLK),
							.iRST(DLY_RST_2)
						);
//D5M raw date convert to RGB data
`ifdef VGA_640x480p60
RAW2RGB				u4	(	.iCLK(D5M_PIXLCLK),
							.iRST(DLY_RST_1),
							.iDATA(mCCD_DATA),
							.iDVAL(mCCD_DVAL),
							.oRed(sCCD_R),
							.oGreen(sCCD_G),
							.oBlue(sCCD_B),
							.oDVAL(sCCD_DVAL),
							.iX_Cont(X_Cont),
							.iY_Cont(Y_Cont)
						);
`else
RAW2RGB				u4	(	.iCLK(D5M_PIXLCLK),
							.iRST_n(DLY_RST_1),
							.iData(mCCD_DATA),
							.iDval(mCCD_DVAL),
							.oRed(sCCD_R),
							.oGreen(sCCD_G),
							.oBlue(sCCD_B),
							.oDval(sCCD_DVAL),
							.iZoom(SW[16]),
							.iX_Cont(X_Cont),
							.iY_Cont(Y_Cont)
						);
`endif

//////////////////////////////////////
///////// DVI Input  /////////////////
//////////////////////////////////////

wire DESync, HSync, VSync;
wire [11:0] Vga_rX, Vga_rY;
wire [7:0] Vga_iR, Vga_iG, Vga_iB, Vga_oR, Vga_og, Vga_ob;

wire controller_DVI_RX_CLK, controller_DVI_RX_DE, controller_DVI_RX_HS, controller_DVI_RX_VS;
wire [23:0]	controller_DVI_RX_D;

wire	[11:0] Dvi_oX, Dvi_oY;
wire	[7:0]	Dvi_oR, Dvi_oG, Dvi_oB;
wire 	Dvi_oCLK, Dvi_oVAL;

assign controller_DVI_RX_CLK = ~VGA_CLK;					//~SW[14] ? ~VGA_CLK : DVI_RX_CLK;
assign controller_DVI_RX_DE = DESync;						//~SW[14] ? DESync : DVI_RX_DE;
assign controller_DVI_RX_HS = HSync; 						//~SW[14] ? HSync : DVI_RX_HS;
assign controller_DVI_RX_VS = VSync;						//~SW[14] ? VSync : DVI_RX_VS;
assign controller_DVI_RX_D = {Vga_oR,Vga_og,Vga_ob}; 	//~SW[14] ? {Vga_oR,Vga_og,Vga_ob} : DVI_RX_D;

//assign GPIO_LA[0] = VGA_CTRL_CLK;
//assign GPIO_LA[1] = VGA_HS;
//assign GPIO_LA[2] = VGA_VS;
//assign GPIO_LA[10:3] = VGA_R;
//assign GPIO_LA[11] = controller_DVI_RX_CLK;
//assign GPIO_LA[12] = controller_DVI_RX_DE;
//assign GPIO_LA[13] = controller_DVI_RX_HS;
//assign GPIO_LA[14] = controller_DVI_RX_VS;
//assign GPIO_LA[22:15] = controller_DVI_RX_D;

imageGenerator imG1(
	.iClk(VGA_CLK),
	.iRST(DLY_RST_1),
	.iRequestX(Vga_rX),
	.iRequestY(Vga_rY),

	.oR(Vga_iR),
	.oG(Vga_iG),
	.oB(Vga_iB)
	);
	
VGAController vga_controller1(
	.iRed(Vga_iR),
	.iGreen(Vga_iG),
	.iBlue(Vga_iB),
	.oRequestX(Vga_rX),
	.oRequestY(Vga_rY),
	.iCLK(VGA_CLK),
	.iRST(DLY_RST_1),

	.oRED(Vga_oR),
	.oGREEN(Vga_og),
	.oBLUE(Vga_ob),
	.oDESYNC(DESync),
	.oHSYNC(HSync),
	.oVSYNC(VSync)//,
	//.oSYNC(),
	//.oBLANK(),
	
	//.oHVCounter()
);

DVI_RX_Controller dvi_rx1(
	.DVI_RX_CLK(controller_DVI_RX_CLK),//~VGA_CLK),//
	.DVI_RX_D(controller_DVI_RX_D),//{Vga_oR,Vga_og,Vga_ob}),//
	.DVI_RX_DE(controller_DVI_RX_DE),//DESync),//
	.DVI_RX_HS(controller_DVI_RX_HS),//HSync),
	.DVI_RX_VS(controller_DVI_RX_VS),//VSync),

	.oX_Counter(Dvi_oX),
	.oY_Counter(Dvi_oY),
	.oDVAL(Dvi_oVAL),
	.oDVI_CLK(Dvi_oCLK),
	.oR(Dvi_oR),
	.oG(Dvi_oG),
	.oB(Dvi_oB)
);




assign LA_PIN[0] = controller_DVI_RX_CLK;
assign LA_PIN[1] = controller_DVI_RX_DE;
assign LA_PIN[2] = controller_DVI_RX_HS;
assign LA_PIN[3] = controller_DVI_RX_VS;
assign LA_PIN[4] = Dvi_oVAL;
assign LA_PIN[5] = Dvi_oCLK;
assign LA_PIN[19:6] = Vga_rX;
assign LA_PIN[20] = D5M_PIXLCLK;





//////////////////////////////////////
///////// lalalalala /////////////////
//////////////////////////////////////

wire			color_fifoSync_valid;
wire 	[7:0]	transform_r, transform_g, transform_b;
wire	[9:0] transform_x, transform_y;

wire 	[43:0]	fifo_sync_q;
wire			fifo_sync_rdempty;
wire			fifo_sync_rdclk;
wire			fifo_sync_rdreq;

wire	[9:0]	homography_sync_x,
				homography_sync_y,
				homography_sync_query_x,
				homography_sync_query_y;
wire	[4:0]	homography_sync_r,
				homography_sync_b;
wire	[5:0]	homography_sync_g;
wire			homography_sync_ready;
wire			homography_sync_start;

wire			sync_sdram_valid;
wire	[4:0]	sync_sdram_ccd_r,
				sync_sdram_ccd_b,
				sync_sdram_dvi_r,
				sync_sdram_dvi_b,
				sdram_r,
				sdram_b;
wire	[5:0]	sync_sdram_ccd_g,
				sync_sdram_dvi_g,
				sdram_g;

wire			homography_sram_request;
wire	[9:0]	homography_sram_X,
				homography_sram_Y;
wire	[4:0]	homography_sram_r,
				homography_sram_b;
wire	[5:0]	homography_sram_g;
wire			homography_sram_Ready;

wire			sram_fifo_rdempty;
wire	[35:0]	sram_fifo_q;
wire			sram_fifo_rdreq;
wire			sram_fifo_rdclk;
wire			sram_clk_125M;

wire			SRAM_WE;

wire			fifo_sync_full,
				fifo_sram_full;
wire	[9:0]	fifo_sram_usedw;

wire			respondToHG;
wire	[9:0]	SRAM_ctrl_CCD_X;

wire	[9:0] 	sync_x, sync_y;
wire 	[7:0]		alt_generator_r_shift, alt_generator_g_shift, alt_generator_b_shift;
wire	[31:0]	alt_generator_mean;
wire  [63:0]	alt_generator_covar,alt_generator_sqrt_covar;
wire 	[31:0] 	covar_float,sqrt_covar_float;
wire			sync_valid;

wire			generator_mask_valid, generator_mask_mask;
wire	[9:0]	generator_mask_x, generator_mask_y;

wire	[9:0]	mask_sdram_x, mask_sdram_y;
wire	[7:0]	mask_sdram_r, mask_sdram_g, mask_sdram_b;
wire			mask_sdram_val, mask_debug;

assign	SRAM_WE_N = ~SRAM_WE;


assign sync_sdram_valid = SW[15] ? mask_sdram_val : sync_valid; //
assign sdram_r =  SW[15] ? 
				( SW[17] ? {5{generator_mask_mask}} : mask_sdram_r ):
				( SW[17] ? sync_sdram_dvi_r : sync_sdram_ccd_r );//
				
assign sdram_g = SW[15] ? 
				( SW[17] ? {6{generator_mask_mask}} : mask_sdram_g ):
				( SW[17] ? sync_sdram_dvi_g : sync_sdram_ccd_g );//
				
assign sdram_b =  SW[15] ? 
				( SW[17] ? {5{generator_mask_mask}} : mask_sdram_b ):
				( SW[17] ? sync_sdram_dvi_b : sync_sdram_ccd_b );//
				

COLOR_TRANSFORM color_transform1(
	.clk_25(Dvi_oCLK),
	.reset(DLY_RST_1),	
	//// input-data ////
	.valid(Dvi_oVAL),
	.x_i(Dvi_oX[9:0]),
	.y_i(Dvi_oY[9:0]),
	.red_i(Dvi_oR),
	.green_i(Dvi_oG),
	.blue_i(Dvi_oB),
	.r_shift_i(alt_generator_r_shift),
	.g_shift_i(alt_generator_g_shift),
	.b_shift_i(alt_generator_b_shift),
	// output port	////
	.wrreq(color_fifoSync_valid),
	//.wrclk_25(),
	//// output-data ////
	.x_o(transform_x),
	.y_o(transform_y),
	.red_o(transform_r),
	.green_o(transform_g),
	.blue_o(transform_b)
);

sync_controller sync(
	.clk_25(~Dvi_oCLK),
	.rst_n(DLY_RST_1),
	.val(sync_valid),
	.sync_x(sync_x),
	.sync_y(sync_y),
	.dvi_r(sync_sdram_dvi_r),
	.dvi_g(sync_sdram_dvi_g),
	.dvi_b(sync_sdram_dvi_b),
	.ccd_r(sync_sdram_ccd_r),
	.ccd_g(sync_sdram_ccd_g),
	.ccd_b(sync_sdram_ccd_b),
	// ColorTransform side
	.q({transform_x, transform_y, transform_r, transform_g, transform_b}),
	.rdreq(color_fifoSync_valid),
	// Homography side
	.return_x(homography_sync_x), // 10 bit
	.return_y(homography_sync_y), // 10 bit
	.r(homography_sync_r), // 5 bit
	.g(homography_sync_g), // 6 bit
	.b(homography_sync_b), // 5 bit
	.ready(homography_sync_ready),
	//.query_x(homography_sync_query_x),
	//.query_y(homography_sync_query_y),
	//.start(homography_sync_start),
	.debug(LEDR[0])
);

FIFO_sync fifo_sync(
	.aclr(~DLY_RST_1),
	.data({transform_x, transform_y, transform_r, transform_g, transform_b}),
	.rdclk(D5M_PIXLCLK),
	.rdreq(fifo_sync_rdreq),
	.wrclk(D5M_PIXLCLK),
	.wrreq(sCCD_DVAL),
	.q(fifo_sync_q),
	.rdempty(fifo_sync_rdempty),
	//.rdusedw(fifo_sync_usedw), // debug
	.wrfull(fifo_sync_full),  // debug
	.wrusedw(fifo_sync_usedw)  // debug
);

CLKSRC clksrc(
	.inclk0(CLOCK_50),
	.c0(sram_clk_125M)
);

SRAM_Controller sram_controller(
	// Homography side
	.iHGRequest(homography_sram_request),
	.iHGX(homography_sram_X),
	.iHGY(homography_sram_Y),
	.oHGRed(homography_sram_r),
	.oHGGreen(homography_sram_g),
	.oHGBlue(homography_sram_b),
	.oReady(homography_sram_Ready),

	// CCD FIFO side
	.iFIFO_ReadEmpty(sram_fifo_rdempty),
	.iFIFO_ReadUsedw(fifo_sram_usedw),
	.iFIFO_Q(sram_fifo_q),
	.oFIFO_ReadRequest(sram_fifo_rdreq),
	.oFIFO_ReadCLK(sram_fifo_rdclk),

	// enable signal
	.iDVI_DVAL(rCCD_DVAL),

	// SRAM side
	.oSRAM_WE(SRAM_WE),
	.oSRAM_ADDR(SRAM_ADDR),
	.ioSRAM_DQ(SRAM_DQ),

	// clock source 125MHz
	.iCLK(sram_clk_125M),
	.iHGCLK(Dvi_oCLK),
	.iRST(DLY_RST_1),
	.oRespondToHG(respondToHG),
	.oDEBUG(SRAM_ctrl_CCD_X)

);

FIFO_sram fifo_sram(
	.aclr(~rCCD_FVAL),
	.data({X_Cont[9:0], Y_Cont[9:0], sCCD_R[11:7], sCCD_G[11:6], sCCD_B[11:7]}),
	.rdclk(sram_fifo_rdclk),
	.rdreq(sram_fifo_rdreq),
	.wrclk(~D5M_PIXLCLK),
	.wrreq(sCCD_DVAL),
	.q(sram_fifo_q),
	.rdempty(sram_fifo_rdempty),
	.rdusedw(fifo_sram_usedw), // debug
	.wrfull(fifo_sram_full),  // debug
	//.wrusedw()  // debug
);

HOMOGRAPHY homography(
	.iCLK(Dvi_oCLK),
	.iRST_N(DLY_RST_1),
	// SRAM
	.iR(homography_sram_r),
	.iG(homography_sram_g),
	.iB(homography_sram_b),
	.iREADY(homography_sram_Ready),
	.oREQ(homography_sram_request),
	.oSRAM_X(homography_sram_X),
	.oSRAM_Y(homography_sram_Y),
	// CONTROLLER
	.iX(transform_x),
	.iY(transform_y),
	.iSTART(color_fifoSync_valid),
	.oCON_X(homography_sync_x),
	.oCON_Y(homography_sync_y),
	.oR(homography_sync_r),
	.oG(homography_sync_g),
	.oB(homography_sync_b),
	.oREADY(homography_sync_ready)
);

COUNTER counter(
    .iCLK(Dvi_oCLK),
    .iRST(DLY_RST_1),
    .iSIGNAL(homography_sram_request)
    //.oCOUNT(LA_PIN[12:3])
);


//////////////////////////////////////
///////// watershed /////////////////
//////////////////////////////////////

ALT alt(
	// input port //
	.clk_pixl(Dvi_oCLK),
	.clk_frame(controller_DVI_RX_VS),
	.reset(DLY_RST_1),
	//// input data ////
	.valid_i(sync_valid),
	.syncX_i(sync_x),
	.syncY_i(sync_y),
	.DVI_R_i(sync_sdram_dvi_r),	// 5 bit
	.DVI_G_i(sync_sdram_dvi_g),	// 6 bit
	.DVI_B_i(sync_sdram_dvi_b),	// 5 bit
	.CCD_R_i(sync_sdram_ccd_r),	// 5 bit 
	.CCD_G_i(sync_sdram_ccd_g), 	// 6 bit
	.CCD_B_i(sync_sdram_ccd_b), 	// 5 bit
	// output port //
	//// output-data ////
	.AMB_SHIFT_R_o(alt_generator_r_shift),
	.AMB_SHIFT_G_o(alt_generator_g_shift),
	.AMB_SHIFT_B_o(alt_generator_b_shift),
	.mean_o(alt_generator_mean),
	.covar_o(alt_generator_covar)
);

convert1 i2f(
	.clock(~Dvi_oCLK),
	.dataa(alt_generator_covar),
	.result(covar_float)
	);

fsqrt sqrt1(
	.clock(Dvi_oCLK),
	.data(covar_float),
	.result(sqrt_covar_float)
	);

convert2 f2i(
	.clock(~Dvi_oCLK),
	.dataa(sqrt_covar_float),
	.result(alt_generator_sqrt_covar)
	);


MASK_GENERATOR mask_generator(
    .clk_25(Dvi_oCLK),
    .rst_n(DLY_RST_1),
    // ALT side
    .threshold(alt_generator_mean + 2*alt_generator_sqrt_covar),//32'b100),//
    // Sync Controller side
    .read(sync_valid),
    .sync_x(sync_x),
    .sync_y(sync_y),
    .ccd_r(sync_sdram_ccd_r),
    .ccd_g(sync_sdram_ccd_g),
    .ccd_b(sync_sdram_ccd_b),
    .dvi_r(sync_sdram_dvi_r),
    .dvi_g(sync_sdram_dvi_g),
    .dvi_b(sync_sdram_dvi_b),
    // Mask side
    .valid(generator_mask_valid),
    .mask(generator_mask_mask),
    .mask_x(generator_mask_x),
    .mask_y(generator_mask_y)
);

MASK mask(
	.iCLK(~Dvi_oCLK),
	.iRST_N(DLY_RST_1),

	// DVI
	.iDVI_VAL(sCCD_DVAL),
	.iDVI_X(X_Cont),
	.iDVI_Y(Y_Cont),
	.iDVI_R(sCCD_R[11:4]),
	.iDVI_G(sCCD_G[11:4]),
	.iDVI_B(sCCD_B[11:4]),

	// mask generator
	.iMASK(generator_mask_mask),
	.iMASK_VAL(generator_mask_valid),
	.iMASK_X(generator_mask_x),
	.iMASK_Y(generator_mask_y),

	// output
	.oX(mask_sdram_x),
	.oY(mask_sdram_y),
	.oR(mask_sdram_r),
	.oG(mask_sdram_g),
	.oB(mask_sdram_b),
	.oVAL(mask_sdram_val),
	.oDEBUG(mask_debug)
);

//assign	LEDR[2]	 = 1'b1;

/*
assign	LA_PIN[0] = D5M_PIXLCLK;
assign	LA_PIN[1] = DLY_RST_1;
assign	LA_PIN[2] = Dvi_oCLK;
assign	LA_PIN[3] = Dvi_oVAL;
//assign	LA_PIN[4] = generator_mask_valid;

assign	LA_PIN[25:16] = Dvi_oX[9:0];
assign	LA_PIN[33:26] = Dvi_oR;
*/
assign	LEDR[16] = fifo_sram_full;


////////////////////////////////////////////
////////////////////////////////////////////



//Frame count display
SEG7_LUT_8 			u5	(	.oSEG0(HEX0),.oSEG1(HEX1),
							.oSEG2(HEX2),.oSEG3(HEX3),
							.oSEG4(HEX4),.oSEG5(HEX5),
							.oSEG6(HEX6),.oSEG7(HEX7),
							.iDIG(Frame_Cont[31:0])
						);

sdram_pll 			u6	(
							.inclk0(CLOCK2_50),
							.c0(sdram_ctrl_clk),
							.c1(DRAM_CLK),
							.c2(D5M_XCLKIN), //25M
`ifdef VGA_640x480p60
							.c3(VGA_CLK)     //25M 
`else
						    .c4(VGA_CLK)     //40M 	
`endif
						);

//SDRam Read and Write as Frame Buffer
Sdram_Control	u7	(	//	HOST Side						
						    .RESET_N(KEY[0]),
							.CLK(sdram_ctrl_clk),

							//	FIFO Write Side 1
							.WR1_DATA({1'b0, sdram_g[5:1],{sdram_b,5'b0}}),
							.WR1(sync_sdram_valid),
							//.WR1_DATA({1'b0, sCCD_G[11:7],sCCD_B[11:2]}),
							//.WR1(sCCD_DVAL),
							.WR1_ADDR(0),
`ifdef VGA_640x480p60
						    .WR1_MAX_ADDR(640*480/2),
						    .WR1_LENGTH(8'h50),
`else
							.WR1_MAX_ADDR(800*600/2),
							.WR1_LENGTH(8'h80),
`endif							
							.WR1_LOAD(!DLY_RST_0),
							.WR1_CLK(~Dvi_oCLK),

							//	FIFO Write Side 2
							.WR2_DATA({1'b0,{sdram_g[0],4'b0},{sdram_r,5'b0}}),
							.WR2(sync_sdram_valid),
							//.WR2_DATA({1'b0, sCCD_G[6:2],sCCD_R[11:2]}),
							//.WR2(sCCD_DVAL),
							.WR2_ADDR(23'h100000),
`ifdef VGA_640x480p60
						    .WR2_MAX_ADDR(23'h100000+640*480/2),
							.WR2_LENGTH(8'h50),
`else							
							.WR2_MAX_ADDR(23'h100000+800*600/2),
							.WR2_LENGTH(8'h80),
`endif	
							.WR2_LOAD(!DLY_RST_0),
							.WR2_CLK(~Dvi_oCLK),

							//	FIFO Read Side 1
						    .RD1_DATA(Read_DATA1),
				        	.RD1(Read),
				        	.RD1_ADDR(0),
`ifdef VGA_640x480p60
						    .RD1_MAX_ADDR(640*480/2),
							.RD1_LENGTH(8'h50),
`else
							.RD1_MAX_ADDR(800*600/2),
							.RD1_LENGTH(8'h80),
`endif
							.RD1_LOAD(!DLY_RST_0),
							.RD1_CLK(~VGA_CTRL_CLK),
							
							//	FIFO Read Side 2
						    .RD2_DATA(Read_DATA2),
							.RD2(Read),
							.RD2_ADDR(23'h100000),
`ifdef VGA_640x480p60
						    .RD2_MAX_ADDR(23'h100000+640*480/2),
							.RD2_LENGTH(8'h50),
`else
							.RD2_MAX_ADDR(23'h100000+800*600/2),
							.RD2_LENGTH(8'h80),
`endif
				        	.RD2_LOAD(!DLY_RST_0),
							.RD2_CLK(~VGA_CTRL_CLK),
							
							//	SDRAM Side
						    .SA(DRAM_ADDR),
							.BA(DRAM_BA),
							.CS_N(DRAM_CS_N),
							.CKE(DRAM_CKE),
							.RAS_N(DRAM_RAS_N),
							.CAS_N(DRAM_CAS_N),
							.WE_N(DRAM_WE_N),
							.DQ(DRAM_DQ),
							.DQM(DRAM_DQM)
						);
//D5M I2C control
I2C_CCD_Config 		u8	(	//	Host Side
							.iCLK(CLOCK2_50),
							.iRST_N(DLY_RST_2),
							.iEXPOSURE_ADJ(KEY[1]),
							.iEXPOSURE_DEC_p(SW[0]),
							.iZOOM_MODE_SW(SW[16]),
							.iTEST_PATTERN_SW(SW[1]),
							.iTEST_PATTERN_MODE(SW[4:2]),
							//	I2C Side
							.I2C_SCLK(D5M_SCLK),
							.I2C_SDAT(D5M_SDATA)
						);
//VGA DISPLAY
VGA_Controller		u1	(	//	Host Side
							.oRequest(Read),
							.iRed(Read_DATA2[9:0]),
							.iGreen({Read_DATA1[14:10],Read_DATA2[14:10]}),
							.iBlue(Read_DATA1[9:0]),
							//	VGA Side
							.oVGA_R(oVGA_R),
							.oVGA_G(oVGA_G),
							.oVGA_B(oVGA_B),
							.oVGA_H_SYNC(VGA_HS),
							.oVGA_V_SYNC(VGA_VS),
							.oVGA_SYNC(VGA_SYNC_N), 
							.oVGA_BLANK(VGA_BLANK_N),
							//	Control Signal
							.iCLK(VGA_CTRL_CLK),
							.iRST_N(DLY_RST_2),
							.iZOOM_MODE_SW(SW[16])
						);

endmodule
